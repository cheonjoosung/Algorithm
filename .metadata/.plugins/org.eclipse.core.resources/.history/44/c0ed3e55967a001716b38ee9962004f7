package codeground;
import java.util.Arrays;
import java.util.Scanner;

//마라톤 경
public class Sol18 {
	static int Answer;

	public static void main(String args[]) throws Exception {
		Scanner sc = new Scanner(System.in);

		int T = sc.nextInt();
		for (int test_case = 0; test_case < T; test_case++) {
			Answer = 0;

			int row = sc.nextInt();
			int col = sc.nextInt();
			int minWater = sc.nextInt();

			int[][] arr = new int[row + 1][col + 1];
			int[][][] dist = new int[row + 1][col + 1][10 + 1]; // ¡ˆ¡°¿ª ¿Ãµø«“ ∂ß∏∂¥Ÿ π∞ « ø‰+∞≈∏Æ

			for (int i = 0; i < (col + 1); i++) 
				for (int j = 0; j < (row + 1); j++) 
					arr[j][i] = sc.nextInt();

			// √ ±‚»≠
			for (int[][] first : dist) 
				for (int[] second : first)
					Arrays.fill(second, -1 );

			/*
			 * [x][y][waterºˆ]=∞Ìµµ¬˜¿««’√÷º“∏¶ ¿Ãµø«œ∏Èº≠ ±∏«—¥Ÿ. 0,0 -> 1,0 -> 2,0 -> 3,0 π∞¿«
			 * µÈæÓ∞°¥¬ ºˆøÕ √÷º“¿« ∞Ìµµ¬˜¿« «’ 1,0 -> 1,1 -> 2,1 -> 3,1 i,j ¿œ∂ß¥¬ i-1, j or i,
			 * j-1 «œø© ∞¢ ∞ËªÍ«— ∞™¿ª ¡˝æÓ≥÷¥¬¥Ÿ. π∞∑– 0∫∏¥Ÿ ¿€¿∏∏È æ»µ«∞Ì row or col ªÁ¿Ã¡Ó∫∏¥Ÿ ≈©¡ˆ æ µµ∑œ
			 * º≥¡§«—¥Ÿ.
			 */

			dist[0][0][0] = 0;

			for (int i = 0; i < (col + 1); i++) {
				for (int j = 0; j < (row + 1); j++) {
					if(i==0 && j==0) continue;

					int left = -1;
					int down = -1;

					if(j >= 1) {
						left = getDistance(arr[j][i], arr[j-1][i]);
					}

					if(i >= 1) {
						down = getDistance(arr[j][i], arr[j][i-1]);
					}

					if(left != -1 && down == -1) { // j=0 ¿œ∂ß
						for(int k=10; k>=0 ; k--) {
							if(dist[j-1][i][k] == -1) continue;

							if( isNagative(arr[j][i]) ) {
								if(k != 10) {
									dist[j][i][k+1] = dist[j-1][i][k] + left;
								} else {
									dist[j][i][k] = dist[j-1][i][k] + left;
								}
							} else {
								dist[j][i][k] = dist[j-1][i][k] + left;
							}
						}
					} else if(left == -1 && down != -1) { // i=0 ¿œ∂ß
						for(int k=10; k>=0 ; k--) {
							if(dist[j][i-1][k] == -1) continue;

							if( isNagative(arr[j][i]) ) {
								if(k != 10) {
									dist[j][i][k+1] = dist[j][i-1][k] + down;
								} else {
									dist[j][i][k] = dist[j][i-1][k] + down;
								}
							} else {
								dist[j][i][k] = dist[j][i-1][k] + down;
							}
						}
					} else { // j >= 1 && j >= 1¿œ ∂ß 
						for(int k=10; k>=0 ; k--) {
							if(dist[j-1][i][k] == -1 && dist[j][i-1][k] == -1) continue;

							if(dist[j-1][i][k] != -1 && dist[j][i-1][k] == -1) { // øﬁ¬ ¿∏∑Œ∏∏ ø¿¥¬ ±Ê∏∏ ¡∏¿Á
								if( isNagative(arr[j][i]) ) {
									if(k != 10) {
										if(dist[j][i][k+1] == -1) {
											dist[j][i][k+1] = dist[j-1][i][k] + left;
										} else {
											dist[j][i][k+1] = Math.min(dist[j][i][k+1], dist[j-1][i][k] + left);
										}
									} else {
										if(dist[j][i][k] == -1) {
											dist[j][i][k] = dist[j-1][i][k] + left;
										} else {
											dist[j][i][k] = Math.min(dist[j][i][k], dist[j-1][i][k] + left);
										}
									}
								} else {
									if(dist[j][i][k] == -1) {
										dist[j][i][k] = dist[j-1][i][k] + left;
									} else {
										dist[j][i][k] = Math.min(dist[j][i][k], dist[j-1][i][k] + left);
									}
								}
							} else if(dist[j-1][i][k] == -1 && dist[j][i-1][k] != -1) { // æ∆∑°∑Œ ø¿¥¬ ±Ê∏∏ ¡∏¿Á
								if( isNagative(arr[j][i]) ) {
									if(k != 10) {
										if(dist[j][i][k+1] == -1) {
											dist[j][i][k+1] = dist[j][i-1][k] + down;
										} else {
											dist[j][i][k+1] = Math.min(dist[j][i][k+1], dist[j][i-1][k] + down);
										}
									} else {
										if(dist[j][i][k] == -1) {
											dist[j][i][k] = dist[j][i-1][k] + down;
										} else {
											dist[j][i][k] = Math.min(dist[j][i][k], dist[j][i-1][k] + down);
										}
									}
								} else {
									if(dist[j][i][k] == -1) {
										dist[j][i][k] = dist[j][i-1][k] + down;
									} else {
										dist[j][i][k] = Math.min(dist[j][i][k], dist[j][i-1][k] + down);
									}
								}
							} else { // æÁ¬ ¿∏∑Œ ø¿¥¬ ±Ê¿Ã ¡∏¿Á
								if( isNagative(arr[j][i]) ) {
									if(k != 10) {
										if(dist[j][i][k+1] == -1) {
											dist[j][i][k+1] = Math.min(dist[j-1][i][k] + left, dist[j][i-1][k] + down);
										} else {
											int val = Math.min(dist[j-1][i][k] + left, dist[j][i-1][k] + down);
											dist[j][i][k+1] = Math.min(dist[j][i][k+1], val);
										}
									} else {
										if(dist[j][i][k] == -1) {
											dist[j][i][k] = Math.min(dist[j-1][i][k] + left, dist[j][i-1][k] + down);
										} else {
											int val = Math.min(dist[j-1][i][k] + left, dist[j][i-1][k] + down);
											dist[j][i][k] = Math.min(dist[j][i][k], val);
										}
									}
								} else {
									if(dist[j][i][k] == -1) {
										dist[j][i][k] = Math.min(dist[j-1][i][k] + left, dist[j][i-1][k] + down);
									} else {
										int val = Math.min(dist[j-1][i][k] + left, dist[j][i-1][k] + down);
										dist[j][i][k] = Math.min(dist[j][i][k], val);
									}
								}
							}
						}
					}
				}
			}

			for(int k=minWater ; k <= 10 ; k++) {
				if(dist[row][col][k] == -1) continue;

				if(Answer == 0) {
					Answer = dist[row][col][k];
					continue;
				}

				Answer = Math.min(Answer, dist[row][col][k]);
			}

			System.out.println("Case #" + (test_case + 1));
			System.out.println(Answer);
		}
	}

	public static int getDistance(int a, int b) {
		a = Math.abs(a);
		b = Math.abs(b);

		if (a > b) {
			return (a - b);
		} else {	
			return (b - a);
		}
	}

	public static boolean isNagative(int a) {
		if(a < 0) return true;
		else return false;
	}
}
